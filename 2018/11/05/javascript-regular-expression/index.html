<!DOCTYPE html><html lang="zh"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="description" content="Aaron&#39;s blog"><meta name="keyword" content="blog,front end,css,html,javascript"><link rel="shortcut icon" href="/css/images/logo.png"><title>javascript正则表达式不完全指南 | Aaron&#39;s Blog</title><link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet"><link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script><script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script></head><div class="wechat-share"><img src="/css/images/logo.png" alt="logo"></div><body><div id="container"><header class="header fixed-header"><div class="header-container"><a class="home-link" href="/"><div class="logo"></div><span><svg height="60" width="250" id="header-svg"><symbol id="s-text"><text text-anchor="left" x="0%" y="50%" dy=".35em">Aaron's Blog</text></symbol><use class="text" xlink:href="#s-text"></use><use class="text" xlink:href="#s-text"></use><use class="text" xlink:href="#s-text"></use><use class="text" xlink:href="#s-text"></use><use class="text" xlink:href="#s-text"></use></svg><style>#header-svg{position:absolute;top:0}@media screen and (max-width:768px){#header-svg{top:-7px}}.text{fill:none;stroke-width:2;stroke-linejoin:round;stroke-dasharray:40 185;stroke-dashoffset:0;-webkit-animation:stroke 8s infinite linear;animation:stroke 8s infinite linear;font-size:40px;line-height:1;height:40px}.text:nth-child(5n+1){stroke:#f2385a;-webkit-animation-delay:-1.6s;animation-delay:-1.6s}.text:nth-child(5n+2){stroke:#f5a503;-webkit-animation-delay:-3.2s;animation-delay:-3.2s}.text:nth-child(5n+3){stroke:#42b983;-webkit-animation-delay:-4.8s;animation-delay:-4.8s}.text:nth-child(5n+4){stroke:#56d9cd;-webkit-animation-delay:-6.4s;animation-delay:-6.4s}.text:nth-child(5n+5){stroke:#3aa1bf;-webkit-animation-delay:-8s;animation-delay:-8s}@-webkit-keyframes stroke{100%{stroke-dashoffset:-225}}@keyframes stroke{100%{stroke-dashoffset:-225}}</style></span></a><ul class="right-list"><li class="list-item"><a href="/" class="item-link">Home</a></li><li class="list-item"><a href="/tags/" class="item-link">Tags</a></li><li class="list-item"><a href="/archives/" class="item-link">Archives</a></li><li class="list-item"><a href="/project/" class="item-link">Project</a></li><li class="list-item"><a href="/about/" class="item-link">About</a></li></ul><div class="menu"><span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></div><div class="menu-mask"><ul class="menu-list"><li class="menu-item"><a href="/" class="menu-link">Home</a></li><li class="menu-item"><a href="/tags/" class="menu-link">Tags</a></li><li class="menu-item"><a href="/archives/" class="menu-link">Archives</a></li><li class="menu-item"><a href="/project/" class="menu-link">Project</a></li><li class="menu-item"><a href="/about/" class="menu-link">About</a></li></ul></div></div></header><div id="article-banner"><h2>javascript正则表达式不完全指南</h2><p class="post-date">2018-11-05</p></div><main class="app-body flex-box"><article class="post-article"><section class="markdown-content"><p>正则表达式(Regular Expression)是用来匹配特定的字符串模式，通过它我们可以对字符串格式进行校验，或者捕获匹配该模式的字符串。其异常强大的字符串处理能力 ，随之而来的 就是有限抽象。很多语言都实现了正则部分以增强对字符串的处理能力，因此掌握正则表达式可以说是编程基本功之一。不同语言之间的正则语法可能会略微有些不同，接下来主要介绍 javascript 中的正则表达式。<br>推荐一个网站：<a href="https://jex.im/regulex" target="_blank" rel="noopener">可视化正则表达式</a></p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="特殊表达字符与转义"><a href="#特殊表达字符与转义" class="headerlink" title="特殊表达字符与转义"></a>特殊表达字符与转义</h2><p>正则有一系列特殊字符来描述字符串的模式关系，特殊字符的组合拼接给予正则表达式异常强大的表达能力。<br>特殊字符主要有 14 个如下：<br><code>^</code>&emsp;<code>$</code>&emsp;<code>()</code>&emsp;<code>[]</code>&emsp;<code>{}</code>&emsp;<code>*</code>&emsp;<code>+</code>&emsp;<code>.</code>&emsp;<code>?</code>&emsp;<code>\</code>&emsp;<code>|</code><br>如果我们需要匹配特殊字符则需要使用 <code>\</code> 来进行转义,需要特别注意的是:</p><ul><li><code>/</code>,斜杠在正则表达式中没有特殊意义，但是当我们使用字面量定义正则表达式时，两个 <code>/</code> 之间是正则表达式，因此需要转义需要匹配的 <code>/</code> 来避免歧义与语法错误</li><li><code>^$</code>,这两个字符指定字符串模式的开始与结尾，因此要匹配这两个字符也需要转义</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"/"</span>.match(<span class="regexp">/\//</span>);</span><br><span class="line"><span class="comment">//["/", index: 0, input: "/", groups: undefined]</span></span><br><span class="line"><span class="string">"\\"</span>.match(<span class="regexp">/\\/</span>);</span><br><span class="line"><span class="comment">//["\", index: 0, input: "\", groups: undefined]</span></span><br><span class="line"><span class="string">"^$"</span>.match(<span class="regexp">/\^\$/</span>);</span><br><span class="line"><span class="comment">//["^$", index: 0, input: "^$", groups: undefined]</span></span><br></pre></td></tr></table></figure><h2 id="字符类别"><a href="#字符类别" class="headerlink" title="字符类别"></a>字符类别</h2><p>正则有一系列表达式来表示字符的类别。</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">.</td><td style="text-align:left">小数点用于匹配任意单个字符，行结束字符除外 \n \r \u2028 \u2029.在字符集中([abc.])匹配 .</td></tr><tr><td style="text-align:left">\d</td><td style="text-align:left">匹配数字等同于[0-9]</td></tr><tr><td style="text-align:left">\D</td><td style="text-align:left">匹配非数字等同于[^0-9]</td></tr><tr><td style="text-align:left">\w</td><td style="text-align:left">匹配数字字母下划线等同于[A-Za-z0-9_]</td></tr><tr><td style="text-align:left">\W</td><td style="text-align:left">匹配非数字字母下划线等同于[^a-za-z0-9_]</td></tr><tr><td style="text-align:left">\s</td><td style="text-align:left">匹配空白符(空格，制表符，换页符，换行符，一些 unicode 字符等)等价于[ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]</td></tr><tr><td style="text-align:left">\S</td><td style="text-align:left">匹配非空白字符</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">匹配单词边界，一个字符的左 右都存在一个”字符边界”，其并没有具体的值，而单词的定义是有 [a-zA-Z0-9+]组成的字符串，而单词之间就是就存在”单词边界”。 我们用 <strong>😁</strong> 来表示边界，则表达式 <strong>example:a+b=3</strong>：字符边界为 <strong>😁e😁x😁a😁m😁p😁l😁e😁:😁a😁+😁b😁=😁3😁</strong>,单词边界为：<strong>😁example😁:😁a😁+😁b😁=😁3😁</strong></td></tr><tr><td style="text-align:left">\B</td><td style="text-align:left">匹配非单词边界</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">匹配一个水平制表符(tap)</td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">匹配一个回车符(Enter)</td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">匹配一个换行符(linefeed）</td></tr><tr><td style="text-align:left">\v</td><td style="text-align:left">匹配一个垂直制表符</td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">匹配一个换页符</td></tr><tr><td style="text-align:left">[\b]</td><td style="text-align:left">匹配一个退格符(backspace)</td></tr><tr><td style="text-align:left">\0</td><td style="text-align:left">匹配 null 字符\u0000</td></tr><tr><td style="text-align:left">\xhh</td><td style="text-align:left">匹配编码为 hh 的字符（256 个）</td></tr><tr><td style="text-align:left">\uhhhh</td><td style="text-align:left">皮配编码为 hhhh 的字符</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">可以用于转义特殊字符</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\n\r\u2028\u2029"</span>.match(<span class="regexp">/./</span>);</span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="string">"\u2007"</span>.match(<span class="regexp">/\u2007/</span>);</span><br><span class="line"><span class="comment">//[" ", index: 0, input: " ", groups: undefined]</span></span><br><span class="line"><span class="string">"1"</span>.match(<span class="string">"\x31"</span>);</span><br><span class="line"><span class="comment">//["1", index: 0, input: "1", groups: undefined]</span></span><br><span class="line"><span class="string">"\u0000"</span>.match(<span class="regexp">/\0/</span>);</span><br><span class="line"><span class="comment">//[" ", index: 0, input: " ", groups: undefined]</span></span><br><span class="line"><span class="string">"\b"</span>.match(<span class="regexp">/[\b]/</span>);</span><br><span class="line"><span class="comment">//匹配退格符</span></span><br><span class="line"><span class="comment">//["", index: 0, input: "", groups: undefined]</span></span><br><span class="line"><span class="string">"怎么回事,little borther"</span>.replace(<span class="regexp">/\b/g</span>, <span class="string">"😄"</span>);</span><br><span class="line"><span class="comment">//"怎么回事,😄little😄 😄borther😄"</span></span><br><span class="line"><span class="string">"怎么回事,little borther"</span>.replace(<span class="regexp">/\B/g</span>, <span class="string">"😄"</span>);</span><br><span class="line"><span class="comment">//"😄怎😄么😄回😄事😄,l😄i😄t😄t😄l😄e b😄o😄r😄t😄h😄e😄r"</span></span><br><span class="line"><span class="string">"怎么回事,little borther"</span>.replace(<span class="regexp">/\B|\b/g</span>, <span class="string">"😄"</span>);</span><br><span class="line"><span class="comment">//"😄怎😄么😄回😄事😄,😄l😄i😄t😄t😄l😄e😄 😄b😄o😄r😄t😄h😄e😄r😄"</span></span><br></pre></td></tr></table></figure><h2 id="数量词"><a href="#数量词" class="headerlink" title="数量词"></a>数量词</h2><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">x*</td><td style="text-align:left">匹配模式 x 0 次及以上</td></tr><tr><td style="text-align:left">x+</td><td style="text-align:left">匹配模式 x 1 次及以上</td></tr><tr><td style="text-align:left">x?</td><td style="text-align:left">匹配模式 x 0 次或 1 次</td></tr><tr><td style="text-align:left">x&#124;y</td><td style="text-align:left">匹配模式 x 或者 y</td></tr><tr><td style="text-align:left">x{n}</td><td style="text-align:left">匹配模式 x 连续出现 n 次 “ruarua”.match(/(rua){3}/),结果为 null<br>“ruarua”.match(/(rua){2}/),结果为[“ruarua”,”rua”]（包括匹配结果和捕获项）<br>“ruarua”.match(/(?:rua){2}/),结果为[“ruarua”]（不包括捕获项）<br>“ruarua”.match(/(rua){1}/g),结果为[“rua”,”rua”]（当存在 g 标识时，不返回捕获项）<br>“ruarua”.match(/(rua){1}/),结果为[“rua”,”rua”]（当不存在 g 标识时，返回捕获项）<br>“ruarua”.match(/(?:rua){1}/),结果为[“rua”]（不包括捕获项）</td></tr><tr><td style="text-align:left">x{n,}</td><td style="text-align:left">匹配模式 x 至少出现 n 次</td></tr><tr><td style="text-align:left">x{n,m}</td><td style="text-align:left">匹配模式 x 至少出现 n 次，至多出现 m 次</td></tr><tr><td style="text-align:left">x+?<br>x*?<br>x??<br>x{n}?<br>x{n,}?<br>x{n,m}?</td><td style="text-align:left">匹配模式 x,取最小匹配（非贪婪模式） ‘aaaaa’.match(/a+?/),结果为[“a”],而不是[“aaaaa”]</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="number">4</span>?<span class="regexp">/.test("abc");</span></span><br><span class="line"><span class="regexp">/</span><span class="number">4</span>+<span class="regexp">/.test("abc");</span></span><br><span class="line"><span class="regexp">/</span><span class="number">4</span>*<span class="regexp">/.test("abc");</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/true false true</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"abcabc"</span>.match(<span class="regexp">/c/g</span>);</span><br><span class="line"><span class="comment">//["c","c"]</span></span><br><span class="line"><span class="string">"abcabc"</span>.match(<span class="regexp">/c(?!a)/g</span>);</span><br><span class="line"><span class="comment">//["c"]</span></span><br><span class="line"><span class="string">"abcabc"</span>.match(<span class="regexp">/c(?=a)/g</span>);</span><br><span class="line"><span class="comment">//["c"]</span></span><br><span class="line"><span class="string">"abc"</span>.match(<span class="regexp">/d|c/</span>);</span><br><span class="line"><span class="comment">//["c", index: 2, input: "abc", groups: undefined]</span></span><br><span class="line"><span class="string">"a"</span>.match(<span class="regexp">/a&#123;2,&#125;/</span>);</span><br><span class="line"><span class="comment">//null</span></span><br></pre></td></tr></table></figure><h2 id="贪婪模式与非贪婪模式"><a href="#贪婪模式与非贪婪模式" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h2><p>贪婪模式与非贪婪模式的切换通过 <strong>?</strong> 进行切换，默认为贪婪模式（最大匹配）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"aaa"</span>.match(<span class="regexp">/a&#123;2,&#125;?/</span>);</span><br><span class="line"><span class="comment">//["c", index: 2, input: "abc", groups: undefined]</span></span><br><span class="line"><span class="string">"aaa"</span>.match(<span class="regexp">/a&#123;2,&#125;/</span>);</span><br><span class="line"><span class="comment">//["aaa", index: 0, input: "aaa", groups: undefined]</span></span><br></pre></td></tr></table></figure><h2 id="字符集合（字符组）"><a href="#字符集合（字符组）" class="headerlink" title="字符集合（字符组）"></a>字符集合（字符组）</h2><p>字符集合表示一个字符可匹配值。可以使用 <strong>-</strong> 来表示连个字符之间的范围,范围为数字字母而且必须从小到大，大小排列顺序为 0-9 ，A-Z ，a-z<br>因此 <strong>[5-x]</strong> 等同于 <strong>[5-9A-Za-x]</strong></p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">[abc]</td><td style="text-align:left">字符集匹配其中任何一个字符</td></tr><tr><td style="text-align:left">[^abc]</td><td style="text-align:left">反义字符集匹配除此之外的任何字符</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"regex"</span>.match(<span class="regexp">/[^abc]/</span>);</span><br><span class="line"><span class="comment">// ["r", index: 0, input: "regex", groups: undefined]</span></span><br><span class="line"><span class="string">"459AZaxz"</span>.match(<span class="regexp">/[5-x]+/</span>);</span><br><span class="line"><span class="comment">//["59AZax", index: 1, input: "459AZaxz", groups: undefined]</span></span><br></pre></td></tr></table></figure><h2 id="捕获组与非捕获组"><a href="#捕获组与非捕获组" class="headerlink" title="捕获组与非捕获组"></a>捕获组与非捕获组</h2><p>使用圆括号可以将一段字符串划分为一组，后面可以接数量词，并且可以被捕获存储。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"abcabcabc"</span>.match(<span class="regexp">/(abc)&#123;2&#125;/</span>);</span><br><span class="line"><span class="comment">//["abcabc", "abc", index: 0, input: "abcabcabc", groups: undefined]</span></span><br></pre></td></tr></table></figure><p>可以使用 <strong>\数字</strong> 的格式来<strong>反向引用</strong>对应的圆括号内的捕获项。捕获项排序由外向内，再由左往右依次排序。<br>引用并不是重复捕获项模式，而是重复捕获项已经匹配的字符串模式，如<code>(\d{2})\1</code>与<code>(\d{2})\d{2}</code>是完全不相同的两个正则表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"abcabbc"</span>.match(<span class="regexp">/(a(b))(c)(\1)(\2)(\3)/</span>);</span><br><span class="line"><span class="comment">//["abcabbc", "ab", "b", "c", "ab", "b", "c", index: 0, input: "abcabbc", groups: undefined]</span></span><br><span class="line"><span class="string">"11322"</span>.match(<span class="regexp">/(\d&#123;2&#125;)3\1/</span>);</span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="string">"11311"</span>.match(<span class="regexp">/(\d&#123;2&#125;)3\1/</span>);</span><br><span class="line"><span class="comment">//\d&#123;2&#125;匹配到‘11’时，正则等同于(\d&#123;2&#125;)311</span></span><br><span class="line"><span class="comment">//["11311", "11", index: 0, input: "11311", groups: undefined]</span></span><br></pre></td></tr></table></figure><p><strong>非捕获组</strong>是在捕获项内前添加<code>?:</code>，可以取消返回该捕获项与该捕获项的引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"123123"</span>.match(<span class="regexp">/(123)/</span>);</span><br><span class="line"><span class="comment">//["123", "123", index: 0, input: "123123", groups: undefined]</span></span><br><span class="line"><span class="string">"123123"</span>.match(<span class="regexp">/(?:123)/</span>);</span><br><span class="line"><span class="comment">//["123", index: 0, input: "123123", groups: undefined]</span></span><br><span class="line"><span class="string">"123123"</span>.match(<span class="regexp">/(123)(\1)/</span>);</span><br><span class="line"><span class="comment">//["123123", "123", "123", index: 0, input: "123123", groups: undefined]</span></span><br><span class="line"><span class="string">"123123"</span>.match(<span class="regexp">/(?:123)(\1)/</span>);</span><br><span class="line"><span class="comment">//(\1)无法获取到捕获项引用</span></span><br><span class="line"><span class="comment">//["123", "", index: 0, input: "123123", groups: undefined]</span></span><br></pre></td></tr></table></figure><p>ES2018 中，可以给捕获项命名在捕获项内最前方添加<code>?&lt;name&gt;</code>命名捕获项，使用<code>\k&lt;key&gt;</code>反向引用捕获项。而且会返回 groups 对象，其中包含正则名于匹配值的键值对。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"aa"</span>.match(<span class="regexp">/(?&lt;getA&gt;a)\k&lt;getA&gt;/</span>);</span><br><span class="line"><span class="comment">//["aa", "a", index: 0, input: "aa", groups: &#123;…&#125;]</span></span><br><span class="line"><span class="string">"aa"</span>.match(<span class="regexp">/(?&lt;getA&gt;a)\k&lt;getA&gt;/</span>).groups;</span><br><span class="line"><span class="comment">//&#123;getA: "a"&#125;</span></span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>正则表达式中使用 <strong>|</strong> 表示分支，<strong>|</strong>左右两边被分为两个部分，匹配其中一个模式，从左往右。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"b"</span>.match(<span class="regexp">/a|b|c/</span>);</span><br><span class="line"><span class="comment">//["b", index: 0, input: "b", groups: undefined]</span></span><br><span class="line"><span class="string">"c"</span>.match(<span class="regexp">/a|b|c/</span>);</span><br><span class="line"><span class="comment">//["c", index: 0, input: "c", groups: undefined]</span></span><br></pre></td></tr></table></figure><p>可以使用捕获项来缩小分支作用范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"ac"</span>.match(<span class="regexp">/a(b|c)/</span>);</span><br><span class="line"><span class="comment">//["ac", "c", index: 0, input: "ac", groups: undefined]</span></span><br><span class="line"><span class="string">"abcde"</span>.match(<span class="regexp">/((a|b)|(c|d))e/</span>);</span><br><span class="line"><span class="comment">//["de", "d", undefined, "d", index: 3, input: "abcde", groups: undefined]</span></span><br></pre></td></tr></table></figure><h2 id="开头与结尾"><a href="#开头与结尾" class="headerlink" title="开头与结尾"></a>开头与结尾</h2><p><code>^</code>与<code>$</code>元字符分别指定字符串的模式的开头与结尾的位置，这两个符号必须出现在第一或者最后一个符号否则无效,匹配这两个字符需要转义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"abbb"</span>.match(<span class="regexp">/b/</span>);</span><br><span class="line"><span class="comment">//["b", index: 1, input: "abbb", groups: undefined]</span></span><br><span class="line"><span class="string">"abbb"</span>.match(<span class="regexp">/^b/</span>);</span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="string">"^a"</span>.match(<span class="regexp">/^\^a$/</span>);</span><br><span class="line"><span class="comment">//["^a", index: 0, input: "^a", groups: undefined]</span></span><br></pre></td></tr></table></figure><h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>零宽(zero-width)是什么意思？指的就是它匹配一个位置，本身没有宽度。<br>断言(assertion)是什么意思？指的是一种判断，断言之前或之后应该有什么或应该没有什么。<br>零宽断言是一种高级的表达方式，可以为指定匹配模式前后的额外匹配模式，只有符合额外的匹配额外模式，该匹配模式才会被匹配。</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">x(?=y)</td><td style="text-align:left"><strong>零宽肯定先行断言</strong> ，匹配模式 x 且仅当后面紧跟着 y 时，才匹配 x。</td></tr><tr><td style="text-align:left">x(?!y)</td><td style="text-align:left"><strong>零宽否定先行断言</strong> ，匹配模式 x 且仅当后面不紧跟着 y 时，才匹配 x。</td></tr><tr><td style="text-align:left">(?&lt;=y)x</td><td style="text-align:left"><strong>零宽肯定后行断言（部分浏览器实现）</strong> ，匹配模式 x 且仅当前面是 y，才匹配 x。</td></tr><tr><td style="text-align:left">(?&lt;!y)x</td><td style="text-align:left"><strong>零宽否定后行断言（部分浏览器实现）</strong> ，匹配模式 x 且仅当前面不是 y，才匹配 x。</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"abac"</span>.match(<span class="regexp">/a(?=c)/</span>);</span><br><span class="line"><span class="comment">//["a", index: 2, input: "abac", groups: undefined]</span></span><br><span class="line"><span class="string">"abac"</span>.match(<span class="regexp">/a(?!c)/</span>);</span><br><span class="line"><span class="comment">//["a", index: 0, input: "abac", groups: undefined]</span></span><br><span class="line"><span class="string">"baca"</span>.match(<span class="regexp">/(?&lt;=c)a/</span>);</span><br><span class="line"><span class="comment">//["a", index: 3, input: "baca", groups: undefined]</span></span><br><span class="line"><span class="string">"baca"</span>.match(<span class="regexp">/(?&lt;!c)a/</span>);</span><br><span class="line"><span class="comment">//["a", index: 1, input: "baca", groups: undefined]</span></span><br></pre></td></tr></table></figure><h2 id="修饰符-flags"><a href="#修饰符-flags" class="headerlink" title="修饰符(flags)"></a>修饰符(flags)</h2><ul><li>g:global match,全局匹配</li><li>i:ignore case,忽略大小写</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"abcAbcabc"</span>.match(<span class="regexp">/a/</span>);</span><br><span class="line"><span class="comment">//["a", index: 0, input: "abcAbcabc", groups: undefined]</span></span><br><span class="line"><span class="string">"abcAbcabc"</span>.match(<span class="regexp">/a/g</span>);</span><br><span class="line"><span class="comment">//["a", "a"]</span></span><br><span class="line"><span class="string">"abcAbcabc"</span>.match(<span class="regexp">/a/gi</span>);</span><br><span class="line"><span class="comment">//["a", "A", "a"]</span></span><br></pre></td></tr></table></figure><ul><li>m:multiline,多行匹配，匹配每一行的开头结尾，而不是整个字符串的开通结尾。（影响<code>$</code>和<code>^</code>元字符的行为）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1\n2"</span>.match(<span class="regexp">/^\d$/</span>);</span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="string">"1\n2"</span>.match(<span class="regexp">/^\d$/m</span>);</span><br><span class="line"><span class="comment">//["1", index: 0, input: "1↵2", groups: undefined]</span></span><br><span class="line"><span class="string">"1\n2"</span>.match(<span class="regexp">/^\d$/gm</span>);</span><br><span class="line"><span class="comment">//["1", "2"]</span></span><br></pre></td></tr></table></figure><ul><li>u(ES2015):unicode,处理码点大于 0xFFFF 的字符，有些字符会用多个\uxxx 来表示一个码点，在这种情况下正则表达式往往无法正确处理，不符合处理逻辑，<code>u</code>修饰符可以让正则正确的处理过大的码点。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷'</span>; <span class="comment">//由两位unicode码组合标识</span></span><br><span class="line">/^.$/.test(s)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">/^.$/u.test(s)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">/\D&#123;<span class="number">2</span>&#125;/.test(s)</span><br><span class="line"><span class="comment">//被错误识别为两位</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">/\D&#123;<span class="number">2</span>&#125;/u.test(<span class="string">'𠮷'</span>)</span><br><span class="line"><span class="comment">//正确识别</span></span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li>y(ES2015):sticky, 粘滞匹配，根据正则表达式 lastIndex(下次进行匹配的索引位置) 属性指定的位置开始匹配，适用于可以指定匹配位置的字符串模式。<br>lastIndex 通常只有在全局匹配中会更新修改，因为其需要从上次匹配的位置继续匹配。<br>但是不同的是，只有当粘滞匹配失败时 lastIndex 会被重置为 0，匹配成功的情况下粘滞匹配的 lastIndex 不会更新，必须手动更新 lastIndex 来指定开始匹配位置。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/0/g</span>,</span><br><span class="line">  re2 = <span class="regexp">/0/y</span>,</span><br><span class="line">  str = <span class="string">"0102"</span>;</span><br><span class="line">re.exec(str);</span><br><span class="line"><span class="comment">//["0", index: 0, input: "0102", groups: undefined]</span></span><br><span class="line">re.lastIndex;</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line">re.exec(str);</span><br><span class="line"><span class="comment">//["0", index: 2, input: "0102", groups: undefined]</span></span><br><span class="line">re.lastIndex;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">re.exec(str);</span><br><span class="line"><span class="comment">//null</span></span><br><span class="line">re.lastIndex;</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line">re.lastIndex = <span class="number">2</span>;</span><br><span class="line">re.exec(str);</span><br><span class="line"><span class="comment">//["0", index: 2, input: "0102", groups: undefined]</span></span><br><span class="line">re.lastIndex;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">re2.exec(str);</span><br><span class="line"><span class="comment">//["0", index: 0, input: "0102", groups: undefined]</span></span><br><span class="line">re2.exec(str);</span><br><span class="line"><span class="comment">//null</span></span><br><span class="line">re2.lastIndex;</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line">re2.lastIndex = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">re2.exec(str);</span><br><span class="line"><span class="comment">//["0", index: 2, input: "0102", groups: undefined]</span></span><br><span class="line">re2.lastIndex;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">re2.exec(str);</span><br><span class="line"><span class="comment">//null</span></span><br><span class="line">re2.lastIndex;</span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>还需要注意一点:</p><blockquote><p>当使用带有 y 标识的匹配模式时，^断言总是会匹配输入的开始位置或者（如果是多行模式）每一行的开始位置。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^foo/y</span>;</span><br><span class="line">regex.lastIndex = <span class="number">2</span>;</span><br><span class="line">regex.test(<span class="string">"..foo"</span>); <span class="comment">// false - 索引2不是字符串的开始</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regex2 = <span class="regexp">/^foo/my</span>;</span><br><span class="line">regex2.lastIndex = <span class="number">2</span>;</span><br><span class="line">regex2.test(<span class="string">"..foo"</span>); <span class="comment">// false - 索引2不是字符串或行的开始</span></span><br><span class="line">regex2.lastIndex = <span class="number">2</span>;</span><br><span class="line">regex2.test(<span class="string">".\nfoo"</span>); <span class="comment">// true - 索引2是行的开始</span></span><br></pre></td></tr></table></figure><ul><li>s(ES2018):singleline,我们知道<code>.</code>并不能匹配所有字符，而 s 修饰符的作用就是使<code>.</code>能匹配所有字符。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1\n2"</span>.match(<span class="regexp">/.&#123;3&#125;/</span>);</span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="string">"1\n2"</span>.match(<span class="regexp">/.&#123;3&#125;/</span>s);</span><br><span class="line"><span class="comment">//["1↵2", index: 0, input: "1↵2", groups: undefined]</span></span><br></pre></td></tr></table></figure><h1 id="相关-API"><a href="#相关-API" class="headerlink" title="相关 API"></a>相关 API</h1><h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><p>正则表达式通常用于匹配字符串中特定的字符串组合模式。<br>创建一个 RegExp 有两种方法：</p><ul><li><code>/pattern/flags</code> 字面量的形式。</li><li><code>new RegExp(pattern[,flags])</code> 调用构造函数的形式。</li><li>ES2015 中可以可以直接将字面量正则表达式传入 RegExp（语法拓展）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/<span class="number">123</span>/;</span><br><span class="line"><span class="comment">//  /123/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/123/gim</span>);</span><br><span class="line"><span class="comment">// /123/gim</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"123"</span>, <span class="string">"gim"</span>);</span><br><span class="line"><span class="comment">// /123/gim</span></span><br></pre></td></tr></table></figure><p>传入非字符串会被隐式转换为字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="literal">NaN</span>);</span><br><span class="line"><span class="comment">// /NaN/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(+<span class="literal">Infinity</span>);</span><br><span class="line"><span class="comment">// /Infinity/(带正号的数值忽略正号)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(-<span class="literal">Infinity</span>);</span><br><span class="line"><span class="comment">// /-Infinity/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// /null/</span></span><br></pre></td></tr></table></figure><h3 id="RegExp-方法"><a href="#RegExp-方法" class="headerlink" title="RegExp 方法"></a>RegExp 方法</h3><p>无自身方法，有实例方法。</p><h3 id="RegExp-属性"><a href="#RegExp-属性" class="headerlink" title="RegExp 属性"></a>RegExp 属性</h3><ul><li><code>RegExp.prototype</code> 实例继承的属性</li><li><code>RegExp.length</code> 只读，值为 2（我也不知道为什么等于 2）。</li><li><code>RegExp.$n</code>,默认为空字符串,其值为上次调用正则匹配对应的第 n 个捕获项，通过这个我们可以不通过 RegExp 实例来获取捕获项的值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/(a)b(c)/.test(<span class="string">"abc"</span>);</span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span>;</span><br><span class="line"><span class="comment">//"a"</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">2</span>;</span><br><span class="line"><span class="comment">//"c"</span></span><br></pre></td></tr></table></figure><h3 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h3><p><strong>RegExp.prototype.exec(str)</strong></p><p>对字符串执行 <strong>一次</strong> 正则匹配。返回结果数组或 null，并更新正则表达式实例对象的属性（lastIndex），匹配成功。<br><strong>即使正则对象带有 g 标识也只进行一次正则匹配</strong>，因此返回的数组第一项为匹配项，后面为各个捕获项。<br>如果为全局匹配则会根据<code>lastIndex</code>属性指定位置开始下一次匹配。<br>通过 <code>exec</code> 方法返回的数组还包含以下几个属性：</p><ul><li>input：原始输入字符串。</li><li>index：整个模式匹配成功的开始位置。</li><li>groups(ES2015),包含具名捕获项键值对的对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re3 = <span class="regexp">/\d/g</span>;</span><br><span class="line"></span><br><span class="line">re3.exec(<span class="string">"123"</span>);</span><br><span class="line"><span class="comment">//["1", index: 0, input: "123", groups: undefined]</span></span><br><span class="line">re3.exec(<span class="string">"123"</span>);</span><br><span class="line"><span class="comment">//["2", index: 1, input: "123", groups: undefined]</span></span><br><span class="line">re3.exec(<span class="string">"123"</span>);</span><br><span class="line"><span class="comment">//["3", index: 2, input: "123", groups: undefined]</span></span><br><span class="line">re3.exec(<span class="string">"123"</span>);</span><br><span class="line"><span class="comment">//null</span></span><br><span class="line">re3.exec(<span class="string">"123"</span>);</span><br><span class="line"><span class="comment">//["1", index: 0, input: "123", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matchArr = <span class="regexp">/(\d)\w(\d)/</span>.exec(<span class="string">"a1b2c3"</span>);</span><br><span class="line"><span class="comment">//["1b2","1","2"]</span></span><br><span class="line">matchArr.input;</span><br><span class="line"><span class="comment">//"a1b2c3"</span></span><br><span class="line">matchArr.index; </span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;</span><br><span class="line"><span class="keyword">var</span> myArray;</span><br><span class="line"><span class="keyword">while</span> ((myArray = reg.exec(<span class="string">"aaa"</span>)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">"Found "</span> + myArray[<span class="number">0</span>] + <span class="string">". "</span>;</span><br><span class="line">  msg += <span class="string">"Next match starts at "</span> + reg.lastIndex;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;</span><br><span class="line">reg.lastIndex;</span><br><span class="line"><span class="comment">//Found a. Next match starts at 1</span></span><br><span class="line"><span class="comment">//Found a. Next match starts at 2</span></span><br><span class="line"><span class="comment">//Found a. Next match starts at 3</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//连续多次调用exec方法查找同一字符串，会从上次匹配结果之后继续查找</span></span><br><span class="line"><span class="comment">//当返回结果为null时，lastIndex重置为0；</span></span><br></pre></td></tr></table></figure><p><strong>RegExp.prototype.test(str)</strong></p><p>检测匹配输入是否有匹配项，返回 true，false。<br>如果正则为全局匹配，则和 exec 方法相同，根据 lastIndex 记录值开始匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d)/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"012"</span>;</span><br><span class="line">reg.test(str);</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">reg.lastIndex;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span>;</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line">reg.test(str);</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">reg.lastIndex;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span>;</span><br><span class="line"><span class="comment">//"1"</span></span><br><span class="line">reg.test(str);</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">reg.lastIndex;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span>;</span><br><span class="line"><span class="comment">//"2"</span></span><br><span class="line">reg.test(str);</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line">reg.lastIndex;</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span>;</span><br><span class="line"><span class="comment">//"2"  最后一次的捕获值</span></span><br></pre></td></tr></table></figure><p><strong>RegExp.prototype.toString()</strong></p><p>返回正则表达式的字符串形式,覆盖 Object.prototype.toString()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/a/.toString();</span><br><span class="line"><span class="comment">//"/a/"</span></span><br></pre></td></tr></table></figure><h3 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h3><p><strong>RegExp.prototype.constructor</strong></p><p>指向实例构造函数 RegExp。</p><p><strong>RegExp.prototype.flag</strong></p><p>正则实例的修饰符字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/<span class="number">123</span>/gim.flags;</span><br><span class="line"><span class="comment">//"gim"</span></span><br></pre></td></tr></table></figure><p><strong>RegExp.prototype.global</strong></p><p>只读，是否全局匹配。</p><p><strong>RegExp.prototype.ignoreCase</strong></p><p>只读，是否忽略大小写。</p><p><strong>RegExp.prototype.lastIndex</strong></p><p>下次开始匹配位置。</p><p><strong>RegExp.prototype.multiline</strong></p><p>只读，是否多行匹配。</p><p><strong>RegExp.prototype.source</strong></p><p>只读，实例对象的正则字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/<span class="number">123</span>/.source;</span><br><span class="line"><span class="comment">//"123"</span></span><br></pre></td></tr></table></figure><p><strong>RegExp.prototype.sticky</strong>（ES2015）</p><p>只读，是否粘滞匹配。</p><h2 id="String-prototype-match-regexp"><a href="#String-prototype-match-regexp" class="headerlink" title="String.prototype.match([regexp])"></a>String.prototype.match([regexp])</h2><p>返回一个数组，包含所有正则匹配项。如果没有匹配项，返回 <code>null</code>。<br>regexp 是一个正则表达式对象，传入非正则表达式参数会 <code>隐式转换</code>（new RegExp(param)）,不传参数等同于传入<code>new RegExp()</code>。</p><blockquote><p>如果正则表达式没有 g 标志，则 str.match() 会返回和 RegExp.exec() 相同的结果。而且返回的 Array 拥有一个额外的 input 属性，该属性包含被解析的原始字符串。另外，还拥有一个 index 属性，该属性表示匹配结果在原字符串中的索引（以 0 开始）。如果正则表达式包含 g 标志，则该方法返回一个 Array ，它包含所有匹配的子字符串而不是匹配对象。捕获组不会被返回(即不返回 index 属性和 input 属性)。如果没有匹配到，则返回 null 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Abc123abc1234"</span>.match(<span class="regexp">/\d&#123;3&#125;/</span>);</span><br><span class="line"><span class="comment">//["123", index: 3, input: "Abc123abc1234", groups: undefined]</span></span><br><span class="line"><span class="string">"Abc123abc1234"</span>.match(<span class="regexp">/\d&#123;3&#125;/g</span>);</span><br><span class="line"><span class="comment">//["123","123"]</span></span><br><span class="line"><span class="string">"Abc123abc1234"</span>.match(<span class="regexp">/abc/g</span>);</span><br><span class="line"><span class="comment">//["abc"]</span></span><br><span class="line"><span class="string">"Abc123abc1234"</span>.match(<span class="regexp">/\d&#123;3&#125;/gi</span>);</span><br><span class="line"><span class="comment">//["Abc", "abc"]</span></span><br><span class="line"><span class="string">"Abc123abc1234"</span>.match();</span><br><span class="line"><span class="comment">//["", index: 0, input: "Abc123abc1234", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="string">"Abc123abc1234"</span>.match(<span class="string">"123"</span>);</span><br><span class="line"><span class="comment">//["123", index: 3, input: "Abc123abc1234", groups: undefined]</span></span><br><span class="line"><span class="comment">//new RegExp("123") ==&gt; /123/</span></span><br></pre></td></tr></table></figure><h2 id="String-prototype-replace-regexp-targetStr-newStr-function"><a href="#String-prototype-replace-regexp-targetStr-newStr-function" class="headerlink" title="String.prototype.replace(regexp|targetStr,newStr|function)"></a>String.prototype.replace(regexp|targetStr,newStr|function)</h2><p>返回一个替换后的新字符串。<br>regexp 正则比匹配项会被第二个参数替换。<br>targetStr 第一个匹配项会被第二个参数替换。<br>newStr 可以插入特殊的变量名</p><table><thead><tr><th style="text-align:center">变量名</th><th>代表值</th></tr></thead><tbody><tr><td style="text-align:center">$$</td><td>插入一个$</td></tr><tr><td style="text-align:center">$&amp;</td><td>插入匹配的子字符串</td></tr><tr><td style="text-align:center">$`</td><td>插入当前匹配子串左边的内容</td></tr><tr><td style="text-align:center">$’</td><td>插入当前匹配子串右边的内容</td></tr><tr><td style="text-align:center">$n</td><td>加入第一个参数是 RegExp 对象，n 小于 100 且为非负整数，插入第 n 个括号匹配的字符串</td></tr></tbody></table><p>function 作为第二参数，当匹配到匹配项时，便执行该函数。参数如下：</p><table><thead><tr><th style="text-align:center">变量名</th><th>代表值</th></tr></thead><tbody><tr><td style="text-align:center">match</td><td>匹配的子串（$&amp;）</td></tr><tr><td style="text-align:center">p1,p2,…,pn</td><td>第 n 个捕获项的匹配子串（$1,…,$n）</td></tr><tr><td style="text-align:center">offset</td><td>匹配项在字符串中的偏移值</td></tr><tr><td style="text-align:center">string</td><td>被匹配字符串</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testStr = <span class="string">"abc123abc123"</span>;</span><br><span class="line"></span><br><span class="line">testStr.replace(<span class="string">"abc"</span>, <span class="string">"rua"</span>); <span class="comment">//"rua123abc123"</span></span><br><span class="line">testStr.replace(<span class="regexp">/abc/</span>, <span class="string">"rua"</span>); <span class="comment">//"rua123abc123"</span></span><br><span class="line">testStr.replace(<span class="regexp">/abc/g</span>, <span class="string">"rua"</span>); <span class="comment">//"rua123rua123"</span></span><br><span class="line"></span><br><span class="line">testStr.replace(<span class="string">"abc"</span>, <span class="string">"$$"</span>); <span class="comment">//"$123abc123"</span></span><br><span class="line">testStr.replace(<span class="string">"abc"</span>, <span class="string">"$&amp;rua"</span>); <span class="comment">//"abcrua123abc123"</span></span><br><span class="line">testStr.replace(<span class="string">"abc"</span>, <span class="string">"$'"</span>); <span class="comment">//"123abc123123abc123"</span></span><br><span class="line">testStr.replace(<span class="string">"abc"</span>, <span class="string">"$`"</span>); <span class="comment">//"123abc123"</span></span><br><span class="line">testStr.replace(<span class="regexp">/abc/g</span>, <span class="string">"$&amp;rua"</span>); <span class="comment">//"abcrua123abcrua123"</span></span><br><span class="line">testStr.replace(<span class="regexp">/abc/g</span>, <span class="string">"$`"</span>); <span class="comment">//"123abc123123"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testStr2 = <span class="string">"a b c d"</span>;</span><br><span class="line"></span><br><span class="line">testStr2.replace(<span class="regexp">/(\w)\s(\w)/</span>, <span class="string">"$2 $1"</span>); <span class="comment">//"b a c d"</span></span><br><span class="line">testStr2.replace(<span class="regexp">/(\w)\s(\w)/</span>, <span class="string">"$3 $2 $1"</span>); <span class="comment">//"$3 b a c d"</span></span><br><span class="line">testStr2.replace(<span class="regexp">/(\w)\s(\w)/g</span>, <span class="string">"$2 $1"</span>); <span class="comment">//"b a d c"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceCallback</span>(<span class="params">match, p1, p2, offest, string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="string">"match:"</span> +</span><br><span class="line">    match +</span><br><span class="line">    <span class="string">";p1:"</span> +</span><br><span class="line">    p1 +</span><br><span class="line">    <span class="string">";p2:"</span> +</span><br><span class="line">    p2 +</span><br><span class="line">    <span class="string">";offset:"</span> +</span><br><span class="line">    offest +</span><br><span class="line">    <span class="string">";string:"</span> +</span><br><span class="line">    string +</span><br><span class="line">    <span class="string">";"</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">testStr2.replace(<span class="regexp">/(\w)\s(\w)/</span>, replaceCallback);</span><br><span class="line"><span class="comment">//"match:a b;p1:a;p2:b;offset:0;string:a b c d; c d"</span></span><br></pre></td></tr></table></figure><h2 id="String-prototype-split-separator-limit"><a href="#String-prototype-split-separator-limit" class="headerlink" title="String.prototype.split([separator[,limit]])"></a>String.prototype.split([separator[,limit]])</h2><p>separetor 表示分割字符串的标识，可以是字符串，正则表达式，忽略则返回包含字符串的数组。<br>limit 表示限制返回数组中分割字符串的 <strong>最大个数</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"a;b;c"</span>.split(<span class="regexp">/;/</span>);</span><br><span class="line"> <span class="comment">//["a", "b", "c"]</span></span><br><span class="line"><span class="string">"a;b;c"</span>.split(); </span><br><span class="line"><span class="comment">//["a;b;c"]</span></span><br><span class="line"><span class="string">"a;b;c"</span>.split(<span class="regexp">/;/</span>, <span class="number">2</span>); </span><br><span class="line"><span class="comment">//["a", "b"]</span></span><br></pre></td></tr></table></figure><h2 id="String-prototype-search-regexp"><a href="#String-prototype-search-regexp" class="headerlink" title="String.prototype.search(regexp)"></a>String.prototype.search(regexp)</h2><p>返回首次匹配的字符串索引，否则返回-1。<br>indexOf 不支持正则表达式。<br>忽略 g 标识。传入非 regexp 参数会进行隐式转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"abc"</span>.indexOf(<span class="regexp">/b/</span>); </span><br><span class="line"><span class="comment">//-1</span></span><br><span class="line"><span class="string">"abc"</span>.search(<span class="regexp">/b/</span>);</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="string">"abc"</span>.search(<span class="string">"b"</span>); </span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/5bda4e6fe51d45681f245274#heading-30" target="_blank" rel="noopener">一次性搞懂 JavaScript 正则表达式之语法</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="noopener">MDN RegExp</a></li></ul></section><div class="tags"><span>Tags:</span> <a href="/tags#regular expressions"><span class="tag-code">regular expressions</span></a></div><div class="nav-container"><a class="nav-left" href="/2018/11/02/deep-shallow-copy/"><span class="nav-arrow">← </span>javascript中的深浅拷贝 </a><a class="nav-right" href="/2018/11/07/javascript-decoration/">\[译\] javascript 装饰器 <span class="nav-arrow">→</span></a></div><div id="disqus_thread"></div></article><aside class="catalog-container"><div class="toc-main"><strong class="toc-title">Catalog</strong><ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#语法"><span class="toc-nav-text">语法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#特殊表达字符与转义"><span class="toc-nav-text">特殊表达字符与转义</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#字符类别"><span class="toc-nav-text">字符类别</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#数量词"><span class="toc-nav-text">数量词</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#贪婪模式与非贪婪模式"><span class="toc-nav-text">贪婪模式与非贪婪模式</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#字符集合（字符组）"><span class="toc-nav-text">字符集合（字符组）</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#捕获组与非捕获组"><span class="toc-nav-text">捕获组与非捕获组</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#分支"><span class="toc-nav-text">分支</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#开头与结尾"><span class="toc-nav-text">开头与结尾</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#零宽断言"><span class="toc-nav-text">零宽断言</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#修饰符-flags"><span class="toc-nav-text">修饰符(flags)</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#相关-API"><span class="toc-nav-text">相关 API</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#RegExp"><span class="toc-nav-text">RegExp</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#RegExp-方法"><span class="toc-nav-text">RegExp 方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#RegExp-属性"><span class="toc-nav-text">RegExp 属性</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#RegExp-实例方法"><span class="toc-nav-text">RegExp 实例方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#RegExp-实例属性"><span class="toc-nav-text">RegExp 实例属性</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#String-prototype-match-regexp"><span class="toc-nav-text">String.prototype.match([regexp])</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#String-prototype-replace-regexp-targetStr-newStr-function"><span class="toc-nav-text">String.prototype.replace(regexp|targetStr,newStr|function)</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#String-prototype-split-separator-limit"><span class="toc-nav-text">String.prototype.split([separator[,limit]])</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#String-prototype-search-regexp"><span class="toc-nav-text">String.prototype.search(regexp)</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#参考链接"><span class="toc-nav-text">参考链接</span></a></li></ol></li></ol></li></ol></div></aside></main><script>(function () {
    var url = 'https://blog.noobcoder.club/2018/11/05/javascript-regular-expression/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url + Math.random())
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function () {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function () {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="' + src + '" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function () {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();</script><script>var disqus_shortname="aaron00101010",disqus_url="https://blog.noobcoder.club/2018/11/05/javascript-regular-expression/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//go.disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><div class="scroll-top"><span class="arrow-icon"></span></div></div><footer class="app-footer"><p class="copyright">&copy; 2018 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a><br>Theme by <a href="https://github.com/yanm1ng">yanm1ng</a></p></footer><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js",function(){FastClick.attach(document.body)})</script><script>var hasLine="true";async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js",function(){$("figure pre").each(function(t,e){var a=$(this).parents("figure");"false"===hasLine&&a.find(".gutter").hide();var s=a.attr("class").split(" ")[1]||"code",i=$(this).html(),h=document.createElement("code");h.className=s,h.innerHTML=i,$(this).attr("class","").empty().html(h),a.attr("data-lang",s.toUpperCase()),hljs.highlightBlock(e)})})</script><script src="/js/script.js"></script></body></html>